
23-09-2025 11:35

Status: #child

Tags: [[Java+]]

---
# HTTP


### 1. Основные отличия **HTTP/1.1** и **HTTP/2**

- **Формат сообщений:**
    
    - **HTTP/1.1** — текстовый протокол. Заголовки и тело передаются в виде текста (читаемого человеком).
        
    - **HTTP/2** — бинарный протокол. Все данные (включая заголовки и тело) передаются в виде фреймов (frames). Это уменьшает накладные расходы на парсинг.
        
- **Мультиплексирование:**
    
    - **HTTP/1.1** — одно TCP-соединение обслуживает только один запрос в момент времени. Для ускорения браузеры открывают несколько соединений (обычно до 6 на домен).
        
    - **HTTP/2** — можно отправлять несколько запросов параллельно по одному TCP-соединению. Ответы приходят фрагментами, и они не блокируют друг друга.
        
- **Сжатие заголовков:**
    
    - **HTTP/1.1** — заголовки передаются «как есть», часто повторяются (например, `User-Agent`, `Cookie`).
        
    - **HTTP/2** — использует **HPACK** для сжатия заголовков, что уменьшает трафик.
        
- **Приоритизация запросов:**
    
    - **HTTP/1.1** — нет встроенной приоритизации.
        
    - **HTTP/2** — можно назначать приоритеты потокам (streams).
        
- **Server Push:**
    
    - **HTTP/1.1** — клиент сам должен запросить ресурс.
        
    - **HTTP/2** — сервер может заранее «толкнуть» (push) ресурсы, зная, что они понадобятся клиенту (например, CSS вместе с HTML).
        

---

### 2. Отличается ли структура запроса?

Да, и довольно сильно:

- **В HTTP/1.1** запрос выглядит как текст:
    
    ```java
    POST /api/login HTTP/1.1 //start line [Request type] [url] [HTTP version]
	Host: example.com //Headers -> key : value
	Content-Type: application/json
	Content-Length: 34
	User-Agent: curl/8.0 // \n
	// \n
	{"username":"alice","password":"1234"} //body
    ```
	Ответ:
	```java
	HTTP/1.1 200 OK //start line [HTTP version] [Status Code] [status name]
	Date: Mon, 23 Sep 2025 12:00:00 GMT //Headers -> key : value
	Content-Type: application/json
	Content-Length: 27
	Connection: keep-alive// \n
	// \n
	{"status":"ok","token":"xyz"} //body
	```
	
    
- В **HTTP/2** данные передаются бинарными фреймами. Текстового вида запроса/ответа как такового **нет**.  
Но если "разобрать" на уровень фреймов, получится примерно так:

**Запрос (в виде фреймов):**

```java
	HEADERS
	  :method = POST
	  :scheme = https
	  :authority = example.com
	  :path = /api/login
	  content-type = application/json
	  content-length = 34
	  user-agent = curl/8.0
	
	DATA
	  {"username":"alice","password":"1234"}
```

**Ответ (фреймы):**

```java
	HEADERS
	  :status = 200
	  content-type = application/json
	  content-length = 27
	  date = Mon, 23 Sep 2025 12:00:00 GMT
	
	DATA
	  {"status":"ok","token":"xyz"}
```

- Заголовки кодируются с помощью **HPACK**.
    
- Всё это упаковано в бинарный **HEADERS frame**.
    
- Тело запроса (например, POST-данные) идёт в **DATA frames**. ~={cyan}(Их может быть несколько)=~

>[!note] **HTTP 2 сообщение передаётся по частям**
>HTTP/2 работает не с «большими сообщениями» (как HTTP/1.1), а разбивает всё на **маленькие бинарные единицы передачи** — **фреймы (frames)**.  
Каждый фрейм содержит:
>
>- заголовок фрейма (9 байт: тип, длина, флаги, stream ID и т. д.),
> - полезные данные (payload).



> [!note] **HTTP 2 - бинарный!**
> Библиотеки скрывают бинарную реализацию. Но «под капотом» в HTTP/2 — это бинарные фреймы вместо текстовых строк.


----
#### [[HTTP - Flashcards|Link to flashcards]]



---
### References:

- [[Виды HTTP запросов]]
- 